# 一个页面从输入 URL 到页面加载显示完成，这个过程中发生了什么？

- DNS 解析
- TCP 链接
- 发送 HTTP 请求
- 服务器处理请求返回 HTTP 报文
- 浏览器解析渲染页面
- 链接结束

## DNS(Domain Name System，域名系统)解析

DNS 解析的过程就是寻找哪台机器上有你需要资源的过程。**网址到 IP 的转换**

## TCP 链接(三次握手)

通信连接的建立需要经历以下三个过程： <br>

- 主机向服务器发送一个建立链接的请求
- 服务器接到请求后发送同意链接的信号
- 主机接到同意请求的信号后，再次向服务器发送确认信号，自此，主机与服务器两者建立链接
  (_三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号_)

## 发送 HTTP 请求

当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。
浏览器根据 URL 内容生成 HTTP 请求，HTTP 请求报文是由三部分组成: 请求行, 请求报头和请求正文

## 服务器处理请求并返回 HTTP 报文

服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；
服务器将得到的 HTML 文件发送给浏览器；
HTTP 响应报文也是由三部分组成: 状态码, 响应报头和响应报文

- 1 状态吗
  - 1XX: 指示信息-表示请求已连接，继续处理
  - 2XX：成功-表示请求已被成功接受
  - 3XX：重定向-要完成请求必须进行更进一步的操作
  - 4XX：客户端错误-请求有语法错误或请求无法实现
  - 5XX：服务器端错误-服务器未能实现合法的请求
- 2 响应报头
  - 常见的响应包头字段有：Server，Connection...
- 3 响应报文
  - 服务器返回给浏览器的文本信息，通常 HTML、CSS、JS，图片等文件放在这部分

## 浏览器解析渲染页面

在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript 等文件，过程同请求 HTML
<br>
浏览器是一个便解析便渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染是并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念：**reflow（回流）**和**repain（重绘）**。页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。
<br>
<br>
JS 的解析是由浏览器中的 JS 解析引擎完成的。JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较时，如 IO 读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。
<br>
<br>
浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS 等。浏览器将重复 1-6 过程下载该资源。请求过程是异步的，并不会影响 HTML 文档进行加载，但是当文档加载过程中遇到 JS 件，HTML 文档会挂起渲染过程，不仅要等到文档中 JS 文件加载完毕还要等待解析执行完毕，才会继续 HTML 的渲染过程。原因是因为 JS 有可能修改 DOM 结构，这就意味着 JS 执行完成前，后续所有源的下载是没有必要的，这就是 JS 阻塞后续资源下载的根本原因。CSS 文件的加载不影响 JS 文件的加载，但是却影响 JS 文件的执行。JS 代码执行前浏览器必须保证 CSS 文件已经下载并加载完毕

## 连接结束

- 主机向服务器发送一个断开链接的请求
- 服务器接到请求后发送确认收到请求的信号
- 服务器向主机发送断开通知
- 主机连接断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接

> **reflow（回流）**和**repain（重绘）**

- **reflow（回流）**：当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流
  - 会导致回流的操作
    - 页面首次渲染
    - 浏览器窗口大小的改变
    - 元素尺寸或位置发生变化
    - 元素内容变化（文字数量或图片大小等等）
    - 元素字体大小的变化
    - 添加或者删除可见的`DOM`元素
    - 激活`CSS`伪类（例如：`:hover`）
    - 查询某些属性或调用某些方法
  - 一些常用且会导致回流的属性和方法
    - clientWidth、clientHeight、clientTop、clientLeft
    - offsetWidth、offsetHeight、offsetTop、offsetLeft
    - scrollWidth、scrollHeight、scrollTop、scrollLeft
    - scrollIntoView()、scrollIntoViewIfNeeded()
    - getComputedStyle()
    - getBoundingClientRect()
    - scrollTo()
- **repain（重绘）**: 页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。
- **性能影响**: 回流比重绘的代价更高(_有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。_) <br>
  **现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。**
- **如何避免**
  - CSS
    - 避免使用 table 布局
    - 尽量可能在 DOM 树的最末端改变 class
    - 避免设置多层内联样式
    - 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
    - 避免使用`CSS`表达式（例如：`calc()`）
  - JavaScript
    - 避免频繁的操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
    - 避免频繁的操作 DOM，创建一个`documentFragment`，在它上面应用所有的 DOM 操作，最后再把它添加到文档中
    - 先为元素设置`display：none`，操作结束后再把它显示出来。因为`dispaly`属性为`none`的元素上进行 DOM 操作不会引发回流和重绘
    - 避免频繁读取会引发回流/重绘的属性，如果确实需要多此使用，就用一个变量缓存起来
    - 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流
